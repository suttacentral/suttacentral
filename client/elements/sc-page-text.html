<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/iron-ajax/iron-ajax.html">

<link rel="import" href="addons/sc-text-node.html">
<link rel="import" href="../styles/sc-text-styles.html">
<link rel="import" href="../styles/sc-text-heading-styles.html">
<link rel="import" href="../styles/sc-text-paragraph-num-styles.html">

<!--
This element loads the plain html pages which are at the moment defined as all pages that have an author
which is not "sujato" or "pali".s It only loads English pages at the moment. Files are loaded from the mockup
directory in `../data/texts/en/bodhi`. The paragraph numbers are loaded from `../data/paragraphtitles.json`
(this file is complete and correct).

The relevant suttaplex card is shown at the top, hidden behind a dropdown (`addons/sc-text-node.html`).

Via the settings-menu in the toolbar, paragraph numbers can be displayed or hidden as requested.

Title, full Author name and Meta data are fired back to the page-selector for use in the toolbar.

Issues:
    - Other language suttas need to be loaded and displayed correctly as well depending on how this will work
    with the backend.
-->
<dom-module id="sc-page-text" attributes="suttatitle suttameta">
  <template>
    <style is="custom-style" include="sc-text-styles sc-text-heading-styles sc-text-paragraph-num-styles">
      .notfound {
        @apply --paper-font-display1;
      }
    </style>
    <iron-ajax id="ajax"
               url="[[_computeURL(suttaPath,author)]]"
               handle-as="text"
               last-response="{{suttaText}}"
               on-response="_loadedHTML"
               last-error='{{notFound}}'></iron-ajax>

    <iron-ajax id="ajaxParagraphs"
               url="../data/paragraphtitles.json"
               handle-as="json"
               last-response="{{paragraphTitles}}"
               on-response="_computePars"></iron-ajax>

    <template is="dom-if" if="[[notFound]]">
      <p class="notfound">Sorry, the page you requested does not exist.</p>
    </template>

    <template is="dom-if" if="[[!notFound]]">
      <sc-text-node category="[[suttaPath]]" input-language="[[inputLanguage]]"></sc-text-node>
      <div id="htmltextcontent" inner-h-t-m-l="[[suttaText]]"></div>
    </template>
  </template>
  <script>
      class SCPageText extends Polymer.Element {
          static get is() { return 'sc-page-text' }

          static get properties() {
              return {
                  suttaPath: {
                      type: String,
                      notify: true
                  },
                  author: {
                      type: String,
                      notify: true
                  },
                  suttaText: {
                      type: String,
                      notify: true,
                      value: function() {
                          return ''
                      }
                  },
                  inputLanguage: String,
                  notFound: Object,

                  // If true, shows the paragraph numbers on the right of the text.
                  // Data is passed on from the toolbar-settings-menu.
                  showParagraphs: {
                      type: Boolean,
                      notify: true,
                      observer: '_addParagraphs'
                  },
                  paragraphTitles: Object
              }
          }

          static get observers() {
              return [
                  '_callAjax(suttaPath,author)',
                  'infoToParent(suttaText)'
              ]
          }

          ready() {
              super.ready();
              console.log('in regular sutta text');
          }


          // Calls the correct sutta text file. Because Polymer tends to load automatic ajax functions first from where they
          // called before parsing the route to the correct page, the additional checks are needed and might have to be
          // adjusted when more authors are added for the segmented text pages.
          _callAjax() {
              return (this.author && this.author !== 'sujato' && this.author !== 'pali') ? this.$.ajax.generateRequest() : '';
          }

          // At the moment only texts by Bhikkhu Bodhi in English are selected so this still has to be developed further.
          _computeURL(category, author) {
              return `api/suttas/${author}/${category}`;
          }

          // After the text file is loaded, it calls the file that contains the paragraph numbers.
          _loadedHTML(e) {
              this.$.ajaxParagraphs.generateRequest();
          }

          // adds a class to the main container to either show or hide paragraph numbers.
          _addParagraphs() {
              const infotext = this.shadowRoot.querySelector('#htmltextcontent');
              return (infotext && !this.showParagraphs) ? infotext.classList.remove('infomode') : (infotext) ? infotext.classList.add('infomode') : '';
          }

          // returns the division-text title from the loaded sutta text
          _computeTitle(suttaText) {
              const matches = suttaText.match(/class="division">(.*?)</);
              return matches ? matches[1] : '';
          }

          // returns the full author information from the loaded sutta text
          _computeAuthor(suttaText) {
              const matches = suttaText.match(/author="(.*?)"/);
              return matches ? matches[1] : '';
          }

          // returns the meta-data from the loaded sutta text
          _computeMeta(suttaText) {
              const matches = suttaText.match(/<aside id="metaarea">((.|\n)*)<\/aside>/);
              return matches ? matches[1] : '';
          }

          // After the paragraph list has been loaded, adds relevant data to the placeholders in the sutta text file.
          _computePars(e) {
              const paragraphTitles = e.detail.response;
              for (let key in paragraphTitles) {
                  const refs = this.shadowRoot.querySelectorAll('.' + key);
                  Array.from(refs).forEach(item => item.innerHTML = item.id.replace(key, ''));
                  Array.from(refs).forEach(item => item.title = paragraphTitles[key]);
              }
              if (this.showParagraphs) {
                  this._addParagraphs()
              }
          }

          // Sends title and meta data to the page-selector for use in the header and toolbar-settings-menu.
          infoToParent(suttaText) {
              this.dispatchEvent(new CustomEvent('eventFromTextPage'), {
                  detail: {
                      suttatitle: this._computeTitle(suttaText) + 'â€”' + this._computeAuthor(suttaText),
                      suttameta: this._computeMeta(suttaText)
                  },
                  bubbles: true, composed: true
              });
          }
      }

      customElements.define(SCPageText.is, SCPageText);
  </script>
</dom-module>
