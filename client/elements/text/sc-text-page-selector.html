<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="../../bower_components/paper-spinner/paper-spinner-lite.html">
<link rel="import" href="../../bower_components/iron-meta/iron-meta.html">
<link rel="import" href="../../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../../bower_components/app-localize-behavior/app-localize-behavior.html">
<link rel="import" href="../../bower_components/sherby-metadata/sherby-metadata.html">

<link rel="import" href="../../elements/text/sc-segmented-text.html">
<link rel="import" href="../../elements/text/sc-simple-text.html">
<link rel="import" href="../../elements/text/sc-stepper.html">
<link rel="import" href="sc-text-image.html">

<!--
  This element makes a server request for a sutta text, dispatches it to the redux store and subsequently shows
  either the simple sutta text view or the segmented view.
-->
<dom-module id="sc-text-page-selector">

  <!-- Import the transliteration module for changing the script of the Pali texts -->
  <script src="transliterator.js"></script>

  <template>
    <style include="sc-text-heading-styles">
      .loading-indicator {
        @apply --sc-skolar-font-size-s;
        text-align: center;
        height: 60px;
        margin-top: 25vh;
      }

      .text-options {
        padding: var(--sc-size-lg);
      }

      .wrapper {
        min-height: calc(100% - var(--sc-size-xxl) * 2.5);
      }

      .text-error {
        @apply --center;
        @apply --sc-sans-font;
        text-align: center;
        color: var(--sc-secondary-text-color);
      }

      .network-error-icon {
        width: var(--sc-size-xxl);
        height: var(--sc-size-xxl);
      }

    </style>

    <iron-meta id="meta"></iron-meta>

    <iron-ajax
        id="sutta_text_ajax"
        url="[[_getSuttaTextUrl()]]"
        debounce-duration="500"
        handle-as="json"
        loading="{{isLoading}}"
        last-error="{{lastError}}"
        last-response="{{responseData}}"></iron-ajax>

    <div class="wrapper">
      <template is="dom-if" if="[[!_shouldDisplayError(rootSutta, translatedSutta, lastError)]]">
        <sc-text-options id="sutta_text_options" class="text-options" suttaplex-item="[[suttaplex]]"></sc-text-options>
      </template>

      <div class="loading-indicator" hidden$="[[!isLoading]]">
        <paper-spinner-lite active="[[isLoading]]"></paper-spinner-lite>
      </div>

      <template is="dom-if" if="[[!_shouldHideSimpleText(isSegmentedText, isLoading)]]">
        <sc-simple-text id="simple_text" sutta="[[translatedSutta]]" is-loading="{{isLoading}}" error="[[lastError]]"
                        hidden$="[[_shouldHideSimpleText(isSegmentedText, isLoading)]]">
        </sc-simple-text>
      </template>

      <template is="dom-if" if="[[!_shouldHideSegmentedText(isSegmentedText, isLoading)]]" restamp>
        <sc-segmented-text id="segmented_text" root-sutta="[[rootSutta]]" markup="[[markup]]"
                           translated-sutta="[[translatedSutta]]" root-lang="[[responseData.root_text.lang]]"
                           is-loading="{{isLoading}}" error="[[lastError]]"
                           hidden$="[[_shouldHideSegmentedText(isSegmentedText, isLoading)]]">
        </sc-segmented-text>
      </template>

      <template is="dom-if" if="[[_shouldDisplayError(rootSutta, translatedSutta, lastError)]]">
        <div class="text-error">
          <iron-icon class="network-error-icon" src="/img/nonetwork.svg"></iron-icon>
          <h2>Error [[lastError.status]]</h2>
          <h3>[[lastError.statusText]]</h3>
        </div>
      </template>

    </div>

    <template is="dom-if" if="[[_shouldDisplayStepper(isLoading, next, previous)]]">
      <sc-stepper next="[[next]]" previous="[[previous]]" lang="[[langIsoCode]]"></sc-stepper>
    </template>

    <sc-text-image id="sc_text_image"></sc-text-image>
    <sherby-metadata data="[[_createMetaData(responseData, localize)]]"></sherby-metadata>

  </template>

  <script>
      /**
       * @extends {Polymer.Element}
       * @appliesMixin Polymer.AppLocalizeBehavior
       */
      class SCTextPageSelector extends Polymer.mixinBehaviors([Polymer.AppLocalizeBehavior], ReduxMixin(Polymer.Element)) {
          static get is() {
              return 'sc-text-page-selector';
          }

          static get properties() {
              return {
                  responseData: {
                      type: Object,
                      observer: '_onResponse'
                  },
                  lastError: {
                      type: Object
                  },
                  author: {
                      type: String
                  },
                  suttaId: {
                      type: String
                  },
                  langIsoCode: {
                      type: String
                  },
                  stopRequests: {
                      type: Boolean
                  },
                  isSegmentedText: {
                      type: Boolean
                  },
                  suttaplex: {
                      type: Object
                  },
                  translatedSutta: {
                      type: Object
                  },
                  rootSutta: {
                      type: Object
                  },
                  markup: {
                      type: String
                  },
                  language: {
                      type: String,
                      statePath: 'siteLanguage',
                      observer: '_siteLanguageChanged'
                  },
                  fallbackLanguage: {
                      type: String,
                      value: 'en'
                  },
                  authorUid: {
                      type: String
                  },
                  authorShort: {
                      type: String
                  },
                  next: {
                      type: Object
                  },
                  previous: {
                      type: Object
                  }
              }
          }

          static get observers() {
              return ['_paramChanged(authorUid, suttaId, langIsoCode)'];
          }

          static get actions() {
              return {
                  changeToolbarTitle(title) {
                      return {
                          type: 'CHANGE_TOOLBAR_TITLE',
                          title: title
                      };
                  },
                  downloadSuttaText(text) {
                      return {
                          type: 'DOWNLOAD_SUTTA_TEXT',
                          text: text
                      }
                  }
              }
          }

          ready() {
              super.ready();
              this.addEventListener('show-image', e => {
                  this.$.sc_text_image.showImage(e.detail);
              });
              this.loadResources(this.resolveUrl(`/localization/elements/sc-text/${this.fallbackLanguage}.json`), this.fallbackLanguage, true);
          }

          _siteLanguageChanged() {
              this.loadResources(this.resolveUrl(`/localization/elements/sc-text/${this.language}.json`), this.language, true);
          }

          _onResponse() {
              if (!this.responseData) {
                  return;
              }
              this.setProperties();
              const textOptions = this.shadowRoot.querySelector('#sutta_text_options');
              if (textOptions) {
                  textOptions._closeSuttaplex();
              }
              this.dispatch('downloadSuttaText', this.responseData);
          }

          setProperties() {
              if (this.responseData) {
                  this.isSegmentedText = !!(this.responseData.segmented);
                  this.suttaplex = this.responseData.suttaplex;
                  this.translatedSutta = this.responseData.translation;
                  this.rootSutta = this.responseData.root_text;
                  this.markup = this.responseData.markup;
                  if (this.responseData.translation) {
                      this.authorUid = this.responseData.translation.author_uid;
                  }
                  if (this.translatedSutta) {
                      this.next = this.translatedSutta.next;
                      this.previous = this.translatedSutta.previous;
                  } else if (this.rootSutta){
                      this.next = this.rootSutta.next;
                      this.previous = this.rootSutta.previous;
                  }
              }
          }

          // The stopRequests variable exists so that we don't make 3 consequent requests in case the
          // author, suttaId and the langIsoCode all change at the same time.
          _paramChanged() {
              if (!this.stopRequests) {
                  this.stopRequests = true;
                  // wait 50ms until all route parameters are changed
                  setTimeout(() => {
                      this.$.sutta_text_ajax.url = this._getSuttaTextUrl();
                      this.$.sutta_text_ajax.generateRequest();
                      this.stopRequests = false;
                  }, 50);
              }
          }

          _shouldHideSimpleText(isSegmentedText, isLoading) {
              return (isSegmentedText || isLoading);
          }

          _shouldHideSegmentedText(isSegmentedText, isLoading) {
              return (!isSegmentedText || isLoading);
          }

          _getSuttaTextUrl() {
              if (this.authorUid) {
                  return `${this.$.meta.byKey('API_ROOT')}/suttas/${this.suttaId}/${this.authorUid}?lang=${this.langIsoCode}`;
              } else {
                  return `${this.$.meta.byKey('API_ROOT')}/suttas/${this.suttaId}?lang=${this.langIsoCode}`;
              }
          }

          _shouldDisplayStepper(isLoading, next, previous) {
              return !isLoading && (next || previous);
          }

          _shouldDisplayError(rootSutta, translatedSutta, networkError) {
              return (!rootSutta && !translatedSutta) || networkError;
          }

          _createMetaData(responseData, localize) {
              if (!responseData) {
                  return;
              }
              let description = localize('metaDescriptionText');
              if (responseData.suttaplex.blurb) {
                  description = responseData.suttaplex.blurb;
              }
              const title = responseData.translation ? responseData.translation.title : responseData.root_text.title;
              const author = responseData.translation ? responseData.translation.author : responseData.root_text.author;

              document.dispatchEvent(new CustomEvent('sherby-metadata', {
                  detail: {
                      title: `${title}â€”${author}`,
                      description: description,
                      bubbles: true,
                      composed: true
                  }
              }));
          }
      }

      customElements.define(SCTextPageSelector.is, SCTextPageSelector);
  </script>
</dom-module>
