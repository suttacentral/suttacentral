<link rel="import" href="/bower_components/polymer/polymer.html">
<link rel="import" href="/bower_components/paper-tooltip/paper-tooltip.html">
<link rel="import" href="/bower_components/paper-spinner/paper-spinner-lite.html">
<link rel="import" href="/bower_components/paper-toast/paper-toast.html">

<link rel="import" href="/elements/text/sc-text-options.html">
<link rel="import" href="/styles/sc-text-styles.html">
<link rel="import" href="/styles/sc-text-heading-styles.html">
<link rel="import" href="/styles/sc-text-paragraph-num-styles.html">
<link rel="import" href="/elements/lookups/sc-pli.html">

<dom-module id="sc-segmented-text">

  <template>
    <style include="sc-text-styles sc-text-heading-styles sc-text-paragraph-num-styles">

      :host {
        --paper-tooltip: {
          @apply --sc-skolar-font-size-s;
          opacity: 1;
          max-width: 200px;
          background-color: var(--sc-paper-tooltip-color);
        }
      }

      .lookup-link {
        color: white !important;
        font-weight: bold;
      }

      .text-center {
        text-align: center;
      }

      .margin-top-xl {
        margin-top: 10vh;
      }

      .loading-indicator {
        @apply --sc-skolar-font-size-s;
        text-align: center;
        height: 60px;
      }

      .highlightable-segment:hover {
        color: var(--sc-primary-accent-color);
      }

    </style>

    <div class="loading-indicator" hidden$="[[!_shouldShowLoadingIndicator(error, isLoading, isTextViewHidden)]]">
      <paper-spinner-lite active="[[isLoading]]"></paper-spinner-lite>
    </div>

    <div id="segmented_text_content" class="html-text-content" inner-h-t-m-l="[[markup]]"
         hidden$="[[isTextViewHidden]]"></div>

    <template is="dom-if" if="[[_shouldShowError(rootSutta, translatedSutta)]]">
      <div class="text-center margin-top-xl">
        <h2>Error</h2>
        <h3>Could not find the sutta text.</h3>
      </div>
    </template>

    <template is="dom-if" if="[[isPaliLookupEnabled]]">
      <sc-pali-lookup id="pali_lookup"></sc-pali-lookup>
    </template>

  </template>

  <script>
      class SCSegmentedText extends ReduxMixin(Polymer.Element) {
          static get is() {
              return 'sc-segmented-text';
          }

          static get properties() {
              return {
                  rootSutta: {
                      type: Object,
                      observer: '_updateView'
                  },
                  translatedSutta: {
                      type: Object,
                      observer: '_updateView'
                  },
                  // If true, shows the paragraph numbers on the right of the text.
                  showParagraphs: {
                      type: Boolean,
                      statePath: 'textOptions.paragraphsEnabled',
                      observer: '_computeParagraphs'
                  },
                  paragraphs: {
                      type: Array,
                      statePath: 'textOptions.paragraphDescriptions'
                  },
                  paragraphTitles: {
                      type: Object
                  },
                  rootAuthor: {
                      type: String
                  },
                  rootLang: {
                      type: String
                  },
                  rootTitle: {
                      type: String
                  },
                  translationAuthor: {
                      type: String
                  },
                  translationLang: {
                      type: String
                  },
                  translatedTitle: {
                      type: String
                  },
                  isLoading: {
                      type: Boolean,
                      observer: '_loadingChanged'
                  },
                  error: {
                      type: Object
                  },
                  isTextViewHidden: {
                      type: Boolean,
                      value: false
                  },
                  hidden: {
                      type: Boolean
                  },
                  chosenTextView: {
                      type: String,
                      statePath: 'textOptions.segmentedSuttaTextView',
                      observer: '_setViewOptions'
                  },
                  paliScript: {
                      type: String,
                      statePath: 'textOptions.script',
                      observer: '_changeScript'
                  },
                  markup: {
                      type: String,
                      observer: '_updateView'
                  },
                  assembledMainText: {
                      type: String
                  },
                  isPaliLookupEnabled: {
                      type: Boolean,
                      statePath: 'textOptions.paliLookupActivated',
                      observer: '_paliLookupStateChanged'
                  },
                  tooltipCount: {
                      type: Number,
                      value: 0
                  },
                  isLookupAllowed: {
                      type: Boolean,
                      value: false
                  },
                  spansGenerated: {
                      type: Boolean,
                      value: false
                  },
                  paliLookupTargetDictRepr: {
                      type: String,
                      statePath: 'textOptions.paliLookupTargetDictRepr',
                      observer: '_paliLookupTargetDictReprChanged'
                  }
              }
          }

          static get actions() {
              return {
                  changeToolbarTitle(title) {
                      return {
                          type: 'CHANGE_TOOLBAR_TITLE',
                          title: title
                      };
                  },
                  changeSuttaMetaText(metaText) {
                      return {
                          type: 'CHANGE_SUTTA_META_TEXT',
                          metaText: metaText
                      }
                  },
                  chooseSegmentedSuttaTextView(viewNumber) {
                      return {
                          type: 'CHOOSE_SEGMENTED_SUTTA_TEXT_VIEW',
                          view: viewNumber
                      }
                  }
              }
          }

          _updateView() {
              if (!this.markup) {
                  return;
              }
              this._resetViewOptions();
              this._setRootAttributes();
              this._setTranslatedAttributes();
              this._updateToolbar();
              this._computeParagraphs();
              this._addTextContent();
              // Scroll to the section after the hash sign in the url:
              this._scrollToSection(window.location.hash.substr(1), false, 500);
              this._changeScript('latin');
              this.dispatch('chooseSegmentedSuttaTextView', 'none');
              this.dispatch('changeSuttaMetaText', this._computeMeta());
          }

          _addTextContent() {
              if (this.translatedSutta) {
                  this._addPrimaryText(this.translatedSutta.strings);
                  if (this.translatedSutta.lang === 'pli' || this.translatedSutta.lang === 'lzh') {
                      this._putWordsIntoSpans('.translated-text');
                  }
              } else {
                  this._addPrimaryText(this.rootSutta.strings);
                  if (this.rootSutta.lang === 'pli' || this.rootSutta.lang === 'lzh') {
                      this._putWordsIntoSpans('.translated-text');
                  }
              }
          }

          _setRootAttributes() {
              if (!this.rootSutta) {
                  this.rootAuthor = this.rootLang = this.rootTitle = null;
                  return;
              }
              this.rootAuthor = this.rootSutta.author;
              this.rootLang = this.rootSutta.lang;
              this.rootTitle = this.rootSutta.title;
          }

          _setTranslatedAttributes() {
              if (!this.translatedSutta) {
                  this.translationAuthor = this.translationLang = this.translatedTitle = null;
                  return;
              }
              this.translationAuthor = this.translatedSutta.author;
              this.translationLang = this.translatedSutta.lang;
              this.translatedTitle = this.translatedSutta.title;
          }

          _updateToolbar() {
              this.dispatch('changeToolbarTitle',
                  `${this.translatedTitle || this.rootTitle} – ${this.translationAuthor || this.rootAuthor}`);
          }

          // returns the meta-data from the loaded sutta text
          _computeMeta() {
              if (this.translatedSutta) {
                  return this.translatedSutta.author_blurb[this.translationLang] || 'No metadata available.';
              } else {
                  return 'No metadata available.';
              }
          }

          // if the base html and the pali texts have been fully loaded, the setting from the
          // settings-menu for the relevant view is implemented by adding relevant class
          // or by adding a paper-tooltip and populating this with the pali text in the chosen script.
          _setViewOptions() {
              if (!this.markup || !this.translatedSutta) {
                  return;
              }
              const textContent = this.$.segmented_text_content;
              this._resetViewOptions();
              switch (this.chosenTextView) {
                  case 'sidebyside':
                      textContent.classList.add('side-by-side');
                      this._addSecondaryText();
                      break;
                  case 'linebyline':
                      textContent.classList.add('line-by-line');
                      this._addSecondaryText();
                      break;
                  case 'popup':
                      this._addPopupTooltips(textContent);
                      break;
              }
              this.assembledMainText = textContent.innerHTML;
          }

          // reset all classes and remove tooltips.
          _resetViewOptions() {
              this.$.segmented_text_content.classList.remove('side-by-side', 'line-by-line', 'show-pali');
              Array.from(this.shadowRoot.querySelectorAll('paper-tooltip')).forEach(item =>
                  item.parentNode.removeChild(item)
              );
              Array.from(this.shadowRoot.querySelectorAll('.translated-text')).forEach(item =>
                  item.classList.remove('highlightable-segment')
              );
          }

          _addPopupTooltips(textContent) {
              Array.from(textContent.querySelectorAll('.translated-text')).forEach(item => {
                      item.innerHTML = `<paper-tooltip class='text-tooltip'
                        fit-to-visible-bounds id=${item.id}></paper-tooltip>${item.innerHTML}`;
                      item.classList.add('highlightable-segment');
                  }
              );
          }

          _addPrimaryText(textStrings) {
              const textContainer = this.shadowRoot.querySelector('#segmented_text_content');
              const segments = textContainer.getElementsByTagName('sc-seg');
              try {
                  this.addSegmentClasses(segments);
                  this.insertTextIntoSegments(textStrings, textContainer);
              }
              catch (e) {
                  console.error(e);
              }
              this.assembledMainText = textContainer.innerHTML;
          }

          addSegmentClasses(segments) {
              let segmentClass = '';
              let classToDelete = '';
              if (this.translatedSutta) {
                  segmentClass = 'translated-text';
                  classToDelete = 'original-text';
              } else {
                  segmentClass = 'original-text';
                  classToDelete = 'translated-text';
              }
              Array.from(segments).forEach(segment => {
                      segment.classList.add(segmentClass);
                      segment.classList.remove(classToDelete);
                      segment.innerHTML = '';
                  }
              );
          }

          insertTextIntoSegments(textStrings, textContainer) {
              Object.entries(textStrings).forEach(([key, value]) => {
                  if (!key.startsWith('_')) {
                      let subkey = key.replace(/:/g, '\\\:').replace(/\./g, '\\\.');
                      const segment = textContainer.querySelector(`#${subkey}`);
                      segment.innerHTML = value + ' ';
                  }
              });
          }

          // creates a second 'sc-element' behind every 'sc-element' in the base markup and
          // populates that with the corresponding pali text segment.
          _addSecondaryText() {
              const textContainer = this.$.segmented_text_content;
              if (!this.shadowRoot.querySelector('.original-text')) {
                  const stringsArr = Object.entries(this.rootSutta.strings);
                  stringsArr.forEach(item => {
                      this.insertSecondarySegment(item);
                  })
                  if (this.rootSutta.lang === 'pli' || this.rootSutta.lang === 'lzh') {
                      this._putWordsIntoSpans('.original-text');
                  }
              }
              textContainer.classList.add('latin-script');
          }

          insertSecondarySegment([key, content]) {
              if (!key.startsWith('_')) {
                  const subkey = key.replace(/:/g, '\\\:').replace(/\./g, '\\\.');
                  const segment = this.$.segmented_text_content.querySelector(`#${subkey}`);
                  const newSegment = document.createElement('sc-seg');
                  newSegment.id = key;
                  newSegment.classList.add('original-text');
                  newSegment.innerHTML = content + ' ';
                  segment.parentNode.insertBefore(newSegment, segment.nextSibling);
              }
          }

          // After the paragraph list has been loaded, adds relevant data to the placeholders in the sutta text file.
          _computeParagraphs() {
              if (this.paragraphs && this.showParagraphs) {
                  this._addParagraphScrollListeners();
                  this.assembledMainText = this.$.segmented_text_content.innerHTML;
              }
              this._setParagraphsVisible(this.showParagraphs);
          }

          _addParagraphScrollListeners() {
              this.paragraphs.forEach((paragraph) => {
                  const refs = this.$.segmented_text_content.querySelectorAll(`.${paragraph.uid}`);
                  Array.from(refs).forEach((item) => {
                      this._addParagraphData(item, paragraph);
                  });
              });
          }

          _addParagraphData(item, data) {
              item.innerHTML = item.id.replace(data.uid, '');
              item.title = data.description;
              item.href = `#${item.id}`;
              if (!item.classList.contains('textual-info-paragraph')) {
                  item.classList.add('textual-info-paragraph');
              }
              item.addEventListener('click', () => {
                  this._scrollToSection(item.id, true, 0);
              });
          }

          // adds a class to the main container to either show or hide the textual info paragraphs
          _setParagraphsVisible(visible) {
              const textElement = this.$.segmented_text_content;
              if (textElement) {
                  visible ? textElement.classList.add('infomode') : textElement.classList.remove('infomode');
              }
          }

          // Display the loading indicator in two cases:
          // 1: If there's no error and the text view is loading, or...
          // 2: If the text view is currently hidden
          _shouldShowLoadingIndicator(error, loading, isTextViewHidden) {
              return ((!error && loading) || isTextViewHidden);
          }

          // Scrolls to the chosen section
          _scrollToSection(sectionId, isSmooth, delay) {
              if (!sectionId) return;
              try {
                  const section = this.shadowRoot.getElementById(sectionId);
                  setTimeout(() => {
                      section.scrollIntoView({
                          behavior: isSmooth ? 'smooth' : 'instant',
                          block: 'start',
                          inline: 'nearest'
                      });
                  }, delay);
              } catch (e) {
                  console.error(e);
              }
          }

          _changeScript(paliScript) {
              if (!this.rootSutta || this.rootSutta.lang !== 'pli') {
                  return;
              }
              const segments = this.shadowRoot.querySelectorAll('.original-text');
              const tooltips = this.shadowRoot.querySelectorAll('paper-tooltip');
              this._resetScript(segments, tooltips);
              switch (paliScript) {
                  case 'latin':
                      this._setScriptISOCode('Latn');
                      this.$.segmented_text_content.classList.add('latin-script');
                      break;
                  case 'sinhala':
                      this._setScriptISOCode('Sinh');
                      this._setScript('sinhala', segments, tooltips);
                      break;
                  case 'devanagari':
                      this._setScriptISOCode('Deva');
                      this._setScript('devanagari', segments, tooltips);
                      break;
                  case 'thai':
                      this._setScriptISOCode('Thai');
                      this._setScript('thai', segments, tooltips);
                      break;
                  case 'myanmar':
                      this._setScriptISOCode('Mymr');
                      this._setScript('myanmar', segments, tooltips);
                      break;
              }
          }

          _setScriptISOCode(isoCode) {
              const textLang = this.translatedSutta ? this.translationLang : this.rootLang;
              const langAttr = this.translatedSutta ? this.translationLang : `${textLang}-${isoCode}`;
              this.shadowRoot.querySelector('#text').setAttribute('lang', langAttr);
          }

          _resetScript(segments, tooltips) {
              this.$.segmented_text_content.classList
                  .remove('latin-script', 'sinhala-script', 'devanagari-script', 'thai-script', 'myanmar-script');
              Array.from(segments).forEach(item => item.innerHTML = this.rootSutta.strings[item.id] + ' ');
              Array.from(tooltips).forEach(item => item.innerHTML = this.rootSutta.strings[item.id]);
          }

          _setScript(scriptName, segments, tooltips) {
              this.$.segmented_text_content.classList.add(`${scriptName}-script`);
              const t = new Transliterator();
              const scriptFn = `to${this._capitalize(scriptName)}`;
              Array.from(segments).forEach(item => item.innerHTML = t[scriptFn](item.innerHTML));
              Array.from(tooltips).forEach(item => item.innerHTML = t[scriptFn](item.innerHTML));
          }

          _capitalize(text) {
              return text.charAt(0).toUpperCase() + text.slice(1);
          }

          _loadingChanged() {
              this.isTextViewHidden = this.isLoading;
          }

          _shouldShowError(rootSutta, translatedSutta) {
              try {
                  if (!translatedSutta) {
                      return rootSutta ? !(rootSutta.strings) : true;
                  }
                  return !(translatedSutta.strings);
              } catch (e) {
                  console.error(e);
              }
          }

          // Lookup word start
          _putWordsIntoSpans(selector) {
              if (!this.isPaliLookupEnabled) {
                  return;
              }
              let segments = this.shadowRoot.querySelectorAll(selector);
              let self = this;
              function process_async(items, process) {
                  const temp = () => {
                      const segment = items.shift();
                      process(segment, self);
                      self._addLookupTooltips(segment, self);
                      if (items.length > 0) {
                          setTimeout(temp, 0);
                      } else {
                          self.spansGenerated = true;
                      }
                  };
                  items = Array.from(items);
                  setTimeout(temp, 0);
              }
              this.isLookupAllowed = false;
              setTimeout(() => {
                  this.isLookupAllowed = true;
              }, 2000); // Allow lookup after 2 seconds.
              process_async(segments, this._putSegmentIntoSpans);
          }

          _putSegmentIntoSpans(segment, self) {
              const text = segment.innerHTML;
              let div = document.createElement('div');
              div.innerHTML = text;
              self._recurseDomChildren(div, true);
              segment.innerHTML = div.innerHTML.replace(/spfrnt/g, `<span class="word">`).replace(/spback/g, '</span>');
          }

          _recurseDomChildren(start, output) {
              let nodes;
              if (start.childNodes) {
                  nodes = start.childNodes;
                  this._loopNodeChildren(nodes, output);
              }
          }

          _loopNodeChildren(nodes, output) {
              let node;
              for (let i = 0; i < nodes.length; i++) {
                  node = nodes[i];
                  this._addSpanToNode(node);
                  if (node.childNodes) {
                      this._recurseDomChildren(node, output);
                  }
              }
          }

          _addSpanToNode(node) {
              if (node.nodeType !== 3) return;
              let tt = node.data;
              let strArr = tt.split(' ');
              let str = '';
              for (let i = 0; i < strArr.length; i++) if (strArr[i]) {
                  str += 'spfrnt' + strArr[i] + 'spback ';
              }
              node.data = str;
          }

          _addTooltip(v, tooltip, paliLookup, states, e) {
              let timeToWait = e.sourceCapabilities.firesTouchEvents ? 10 : 100;
              tooltip.innerHTML = paliLookup.lookupWord(v.innerText);
              v.parentNode.insertBefore(tooltip, v.nextSibling);
              setTimeout(() => {
                  if (states.isWordHovered && !states.isTooltipShown) {
                      v.id = `lookup_target${this.tooltipCount}`;
                      tooltip.for = `lookup_target${this.tooltipCount}`;
                      this.tooltipCount++;
                      tooltip.show();
                      states.isTooltipShown = true;
                  }
              }, timeToWait);
          }

          _removeTooltip(v, tooltip, states, e) {
              let timeToWait = e.sourceCapabilities.firesTouchEvents ? 10 : 100;
              setTimeout(() => {
                  if (!states.isWordHovered && !states.isTooltipHovered) {
                      v.style.color = '';
                      v.removeAttribute('id');
                      tooltip.hide();
                      states.isTooltipShown = false;
                  }
              }, timeToWait);
          }

          _addLookupTooltips(textContainer, self) {
              self = self || this;
              if (!self.isPaliLookupEnabled) {
                  return;
              }
              let paliLookup = self.shadowRoot.querySelector('#pali_lookup');
              textContainer.querySelectorAll('.word').forEach((v) => {
                  let tooltip = document.createElement('paper-tooltip');
                  tooltip.animationDelay = 0;
                  tooltip.manualMode = true;
                  tooltip.fitToVisibleBounds = true;
                  tooltip.offset = 0;
                  let states = {
                      isWordHovered: false,
                      isTooltipHovered: false,
                      isTooltipShown: false
                  };
                  v.addEventListener('mouseover', (e) => {
                      if (this.isPaliLookupEnabled && this.isLookupAllowed) {
                          v.style.color = this._getAccentColor(); // It can not be in class because of some strange bug in some cases.
                          states.isWordHovered = true;
                          self._addTooltip(v, tooltip, paliLookup, states, e);
                      }
                  });
                  v.addEventListener('mouseout', (e) => {
                      states.isWordHovered = false;
                      setTimeout(() => {
                          if (!states.isTooltipHovered) {
                              v.style.color = '';
                          }
                      }, 0);
                      self._removeTooltip(v, tooltip, states, e);
                  });
                  tooltip.addEventListener('mouseover', (e) => {
                      states.isTooltipHovered = true;
                  });
                  tooltip.addEventListener('mouseout', (e) => {
                      states.isTooltipHovered = false;
                      self._removeTooltip(v, tooltip, states, e);
                  });
              })
          }

          _getAccentColor() {
              const bodyStyle = window.getComputedStyle(document.body);
              return bodyStyle.getPropertyValue('--sc-primary-accent-color');
          }

          _paliLookupStateChanged() {
              if (this.hidden) {
                  return;
              }
              if (this.isPaliLookupEnabled) {
                  if (!this.spansGenerated) {
                      this._conditionalyPutWordsIntoSpans();
                  }
              }
          }

          _conditionalyPutWordsIntoSpans() {
              if (this.translatedSutta &&
                  (this.translatedSutta.lang === 'pli' || this.translatedSutta.lang === 'lzh')) {
                  this._putWordsIntoSpans('.translated-text');
              } else if (this.rootSutta.lang === 'pli' || this.rootSutta.lang === 'lzh') {
                  if (this.shadowRoot.querySelector('.original-text')) {
                      this._putWordsIntoSpans('.original-text');
                  }
              }
          }

          _paliLookupTargetDictReprChanged() {
              if (this.isPaliLookupEnabled) {
                  const dictName = this.paliLookupTargetDictRepr.replace('→', 'to');
                  this.dispatchEvent(new CustomEvent('show-sc-toast', {
                      detail: {
                          toastType: 'info',
                          message: `The ${dictName} lookup dictionary is now enabled.`
                      },
                      bubbles: true,
                      composed: true
                  }));
              }
          }
          // Lookup word end
      }

      customElements.define(SCSegmentedText.is, SCSegmentedText);
  </script>
</dom-module>
